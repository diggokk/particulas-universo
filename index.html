<script>
// ... (código anterior permanece igual até a função updateEnemies)

function updateEnemies() {
    enemies.forEach((enemy, index) => {
        // Movimento inteligente (sem mudanças)
        if (Math.random() > 0.95) {
            let avgX = 0, avgY = 0, count = 0;
            particles.forEach(p => {
                const dist = Math.sqrt((p.x - enemy.x)**2 + (p.y - enemy.y)**2);
                if (dist < 200) {
                    avgX += p.x;
                    avgY += p.y;
                    count++;
                }
            });
            
            if (count > 0) {
                avgX /= count;
                avgY /= count;
                const angle = Math.atan2(avgY - enemy.y, avgX - enemy.x);
                enemy.speedX = Math.cos(angle) * 2;
                enemy.speedY = Math.sin(angle) * 2;
            }
        }
        
        // Movimento e colisão com bordas (sem mudanças)
        enemy.x += enemy.speedX;
        enemy.y += enemy.speedY;
        
        if (enemy.x < enemy.size/2) enemy.x = enemy.size/2;
        if (enemy.x > canvas.width - enemy.size/2) enemy.x = canvas.width - enemy.size/2;
        if (enemy.y < enemy.size/2) enemy.y = enemy.size/2;
        if (enemy.y > canvas.height - enemy.size/2) enemy.y = canvas.height - enemy.size/2;
        
        // REMOVIDO: Sistema de dano aos inimigos
    });
}

// Modo Buraco Negro Modificado
function animate() {
    // ... (código anterior permanece)
    
    particles.forEach((p, index) => {
        // ... (outras físicas permanecem)
        
        // Modo Buraco Negro - Versão Modificada
        if (mouse.x && mouse.y && config.mode === 'attract') {
            const dx = mouse.x - p.x;
            const dy = mouse.y - p.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const maxDist = config.mouseRadius * 0.8; // 20% menor
            
            if (distance < maxDist) {
                const force = (maxDist - distance) / maxDist;
                const angle = Math.atan2(dy, dx);
                
                // Atração mais suave (50% da força original)
                p.speedX += dx * 0.04 * force * config.power;
                p.speedY += dy * 0.04 * force * config.power;
                
                // "Engole" partículas muito próximas
                if (distance < maxDist * 0.2) {
                    particles.splice(index, 1);
                    addXP(3); // Ganha XP por engolir partículas
                    
                    // Efeito visual
                    const spark = document.createElement('div');
                    spark.style.position = 'fixed';
                    spark.style.left = `${p.x}px`;
                    spark.style.top = `${p.y}px`;
                    spark.style.width = '5px';
                    spark.style.height = '5px';
                    spark.style.borderRadius = '50%';
                    spark.style.background = p.color;
                    spark.style.boxShadow = `0 0 10px ${p.color}`;
                    spark.style.transition = 'all 0.3s';
                    document.body.appendChild(spark);
                    
                    setTimeout(() => {
                        spark.style.transform = `translate(${mouse.x-p.x}px, ${mouse.y-p.y}px) scale(0)`;
                        spark.style.opacity = '0';
                        setTimeout(() => spark.remove(), 300);
                    }, 10);
                }
            }
        }
    });
    
    // ... (restante do código permanece)
}

// ... (restante do código permanece igual)
</script>