<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Universo de Part√≠culas PRO Turbo - Edi√ß√£o Definitiva</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: radial-gradient(ellipse at bottom, #1B2735 0%, #090A0F 100%);
            touch-action: manipulation;
            font-family: Arial, sans-serif;
            transition: background 1s;
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        .mobile-controls {
            display: none;
            position: fixed;
            bottom: 15px;
            left: 0;
            right: 0;
            justify-content: center;
            gap: 10px;
            padding: 10px;
            z-index: 100;
        }

        .mobile-btn {
            width: 64px;
            height: 64px;
            background: transparent !important;
            border: none !important;
            color: white;
            font-size: 32px !important;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s !important;
        }

        .mobile-btn:active {
            transform: scale(0.8) rotate(15deg) !important;
        }

        /* Menu Hamburguer */
        #menu-toggle {
            position: fixed;
            top: 15px;
            right: 15px;
            z-index: 1000;
            background: rgba(0,0,0,0.7);
            border: none;
            color: white;
            font-size: 24px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }

        #menu {
            position: fixed;
            top: 65px;
            right: 15px;
            z-index: 1000;
            background: rgba(0,0,0,0.9);
            border-radius: 10px;
            padding: 10px;
            color: white;
            display: none;
            width: 200px;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }

        .menu-item {
            padding: 12px 0;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            cursor: pointer;
            transition: all 0.3s;
            background: transparent !important;
            font-size: 18px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .menu-item:hover {
            transform: translateX(5px);
            color: #00F5A0 !important;
        }

        #menu-attract { color: #8A2BE2; }
        #menu-repel { color: #FF4500; }
        #menu-vortex { color: #00BFFF; }
        #menu-normal { color: #4A00E0; }

        .menu-section h4 {
            color: #00F5A0;
            margin-bottom: 5px;
            border-bottom: 1px solid rgba(0,245,160,0.3);
            padding-bottom: 5px;
        }

        #galaxy-map {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            padding: 20px;
            border-radius: 10px;
            color: white;
            z-index: 1000;
            display: none;
            text-align: center;
            max-width: 90%;
            max-height: 90%;
            overflow-y: auto;
        }

        .galaxy {
            margin: 15px;
            padding: 15px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            border: 2px solid transparent;
            background: rgba(0,0,0,0.3);
            text-align: center;
        }

        .galaxy.unlocked {
            background: rgba(0,0,0,0.5);
        }

        .galaxy.unlocked:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px currentColor;
            background: rgba(0,0,0,0.7);
        }

        .galaxy.locked {
            opacity: 0.6;
            cursor: not-allowed;
            background: rgba(0,0,0,0.2);
        }

        .galaxy h3 {
            margin: 10px 0 5px;
        }

        .galaxy p {
            margin: 5px 0;
            font-size: 14px;
            color: #ccc;
        }

        .galaxy small {
            display: block;
            margin-top: 5px;
            color: #ff5555;
        }

        #fps-counter {
            position: fixed;
            top: 10px;
            right: 60px;
            color: white;
            background: rgba(0,0,0,0.5);
            padding: 5px 10px;
            border-radius: 3px;
            font-family: monospace;
        }

        #xp-bar-container {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 20px;
            background: rgba(0,0,0,0.7);
            z-index: 50;
            display: flex;
            align-items: center;
            padding: 0 10px;
        }

        #xp-bar {
            height: 60%;
            width: 0%;
            background: linear-gradient(90deg, #4A00E0, #8E2DE2);
            transition: width 0.3s;
            border-radius: 3px;
        }

        #xp-text {
            color: white;
            margin-left: 10px;
            font-size: 12px;
            font-family: Arial, sans-serif;
        }

        #health-bar-container {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            height: 15px;
            width: 200px;
            background: rgba(0,0,0,0.7);
            z-index: 50;
            border-radius: 10px;
            overflow: hidden;
        }

        #health-bar {
            height: 100%;
            width: 100%;
            transition: width 0.3s;
        }

        #bigbang-cooldown {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            height: 10px;
            width: 150px;
            background: rgba(0,0,0,0.7);
            z-index: 50;
            border-radius: 5px;
            overflow: hidden;
        }

        #bigbang-progress {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #FF00FF, #00FFFF);
            transition: width 0.1s;
        }

        .enemy {
            position: absolute;
            border-radius: 50%;
            z-index: 10;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-family: monospace;
            text-shadow: 0 0 5px black;
            transition: transform 0.2s;
        }

        .enemy.normal {
            background: radial-gradient(circle, rgba(255,100,100,0.8), rgba(150,0,0,0.9));
            box-shadow: 0 0 20px rgba(255,50,50,0.7);
        }

        .enemy.elite {
            background: radial-gradient(circle, rgba(255,215,0,0.8), rgba(255,100,0,0.9));
            box-shadow: 0 0 30px rgba(255,215,0,0.7);
        }

        .enemy.blackhole {
            background: radial-gradient(circle, rgba(0,0,0,0.9), rgba(50,0,100,0.9));
            box-shadow: 0 0 40px rgba(100,0,255,0.7);
        }

        .enemy.boss {
            background: radial-gradient(circle, rgba(150,0,255,0.8), rgba(50,0,150,0.9));
            box-shadow: 0 0 50px rgba(150,0,255,0.7), 
                        0 0 100px rgba(255,0,255,0.5);
            animation: bossPulse 3s infinite;
        }

        @keyframes bossPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        .mobile-controls#mobile-controls-p2 {
            bottom: 80px;
            display: none;
            background: rgba(0,0,0,0.5);
            border-radius: 30px;
            margin: 0 20px;
            padding: 10px 20px;
        }

        #bigbang-btn {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 200px;
            height: 50px;
            border-radius: 25px;
            background: linear-gradient(90deg, #FF00FF, #00FFFF);
            border: 2px solid rgba(255,255,255,0.5);
            color: white;
            font-size: 18px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 100;
            box-shadow: 0 0 20px rgba(255, 0, 255, 0.7);
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.3s;
            opacity: 0.7;
        }

        #bigbang-btn.ready {
            opacity: 1;
            box-shadow: 0 0 30px rgba(255, 0, 255, 0.9), 
                        0 0 60px rgba(0, 255, 255, 0.5);
            animation: pulse 2s infinite;
        }

        #bigbang-btn:active {
            transform: translateX(-50%) scale(0.95);
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 20px rgba(255, 0, 255, 0.7); }
            50% { box-shadow: 0 0 40px rgba(255, 0, 255, 0.9), 
                              0 0 80px rgba(0, 255, 255, 0.7); }
            100% { box-shadow: 0 0 20px rgba(255, 0, 255, 0.7); }
        }

        .player-indicator {
            position: fixed;
            top: 10px;
            color: white;
            font-size: 12px;
            background: rgba(0,0,0,0.5);
            padding: 2px 8px;
            border-radius: 10px;
        }

        #player1-indicator {
            left: 10px;
            border: 1px solid #4A00E0;
        }

        #player2-indicator {
            left: 120px;
            border: 1px solid #00F5A0;
            display: none;
        }

        .unlock-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.5);
            background-color: rgba(0,0,0,0.9);
            color: #00F5A0;
            padding: 20px 30px;
            border-radius: 10px;
            z-index: 10000;
            text-align: center;
            font-size: 24px;
            box-shadow: 0 0 20px #00F5A0;
            border: 2px solid #00F5A0;
            font-weight: bold;
            opacity: 0;
            transition: all 0.3s ease-out;
            pointer-events: none;
            width: 80%;
            max-width: 400px;
        }

        .universe-restart-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0,0,0,0.9);
            color: #FF00FF;
            padding: 20px 40px;
            border-radius: 10px;
            z-index: 10000;
            text-align: center;
            font-size: 28px;
            box-shadow: 0 0 30px #FF00FF;
            border: 2px solid #00FFFF;
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
            text-transform: uppercase;
            max-width: 80%;
        }

        @keyframes shieldPulse {
            0% { box-shadow: 0 0 10px #00F5A0; opacity: 1; }
            50% { box-shadow: 0 0 30px #00F5A0; opacity: 0.7; }
            100% { box-shadow: 0 0 10px #00F5A0; opacity: 1; }
        }

        @keyframes healFade {
            0% { transform: scale(0.5); opacity: 1; }
            100% { transform: scale(2); opacity: 0; }
        }

        @keyframes teleportFade {
            0% { transform: scale(0.1); opacity: 1; }
            50% { transform: scale(1.2); opacity: 0.8; }
            100% { transform: scale(1); opacity: 0; }
        }

        .coop-combo {
            position: fixed;
            bottom: 70px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 16px;
            background: rgba(0,0,0,0.7);
            padding: 5px 15px;
            border-radius: 20px;
            z-index: 100;
            display: none;
            text-align: center;
        }

        .combo-count {
            font-weight: bold;
            color: #00F5A0;
            font-size: 20px;
        }

        @media (max-width: 768px) {
            .mobile-controls { display: flex; }
            #menu {
                width: 80%;
                right: 10px;
                left: 10px;
                margin: 0 auto;
            }
            #bigbang-btn {
                width: 180px;
                height: 45px;
                font-size: 16px;
                bottom: 15px;
            }
            .mobile-btn {
                width: 50px;
                height: 50px;
                font-size: 28px !important;
            }
        }
    </style>
</head>
<body>
    <!-- Indicadores de Jogador -->
    <div class="player-indicator" id="player1-indicator">Jogador 1</div>
    <div class="player-indicator" id="player2-indicator">Jogador 2</div>

    <!-- Menu Hamburguer -->
    <button id="menu-toggle">‚ò∞</button>
    <div id="menu">
        <div class="menu-section">
            <h4>Controles</h4>
            <div class="menu-item" id="menu-attract">üåÄ Atra√ß√£o</div>
            <div class="menu-item" id="menu-repel">üí• Repuls√£o</div>
            <div class="menu-item" id="menu-vortex">üå™Ô∏è V√≥rtice</div>
            <div class="menu-item" id="menu-normal">üë§ Normal</div>
        </div>

        <div class="menu-section">
            <h4>Modos</h4>
            <div class="menu-item" id="menu-coop">üîµ Cooperativo: OFF</div>
            <div class="menu-item" id="menu-show-galaxies">üåå Gal√°xias</div>
        </div>

        <div class="menu-section">
            <h4>Sistema</h4>
            <div class="menu-item" id="menu-reset">üîÑ Reiniciar</div>
        </div>
    </div>

    <!-- Bot√£o Big Bang -->
    <div id="bigbang-btn" title="BIG BANG (Espa√ßo)">BIG BANG</div>

    <!-- Controles mobile -->
    <div class="mobile-controls">
        <button class="mobile-btn" id="mobileAttract" title="Modo Atra√ß√£o">üåÄ</button>
        <button class="mobile-btn" id="mobileRepel" title="Modo Repuls√£o">üí•</button>
        <button class="mobile-btn" id="mobileVortex" title="Modo V√≥rtice">üå™Ô∏è</button>
    </div>

    <!-- Controles mobile jogador 2 -->
    <div class="mobile-controls" id="mobile-controls-p2">
        <button class="mobile-btn" id="mobileShieldP2" title="Escudo (Q)">üõ°Ô∏è</button>
        <button class="mobile-btn" id="mobileHealP2" title="Cura (E)">‚ù§Ô∏è</button>
        <button class="mobile-btn" id="mobileTeleportP2" title="Teletransporte (R)">üîÆ</button>
    </div>

    <div id="galaxy-map">
        <h2>Mapa Gal√°ctico</h2>
        <div id="galaxies-list"></div>
        <button id="close-galaxy-map">Fechar</button>
    </div>

    <div id="fps-counter">FPS: 60</div>

    <div id="health-bar-container">
        <div id="health-bar"></div>
    </div>

    <div id="xp-bar-container">
        <div id="xp-bar"></div>
        <div id="xp-text">0/100 XP (N√≠vel 1)</div>
    </div>

    <div id="bigbang-cooldown">
        <div id="bigbang-progress"></div>
    </div>

    <canvas id="canvas"></canvas>

    <script>
        // Inicializa√ß√£o do canvas
const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d");
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Posicionamento inicial dos jogadores (ADICIONADO)
        config.players[0].x = canvas.width / 2;
        config.players[0].y = canvas.height / 2;
        config.players[1].x = canvas.width / 3;
        config.players[1].y = canvas.height / 3;

// Configura√ß√µes do jogo
        const config = {
            particleCount: 200,
            mouseRadius: 150,
            mode: 'normal',
            galaxies: {
                unlocked: ['classica'],
                current: 'classica'
            },
            xp: 0,
            level: 1,
            power: 1,
            health: 100,
            maxHealth: 100,
            bigBangCooldown: 0,
            bigBangMaxCooldown: 300,
            isBigBangActive: false,
            players: [
                {
                    id: 1,
                    x: null,
                    y: null,
                    mode: 'normal',
                    color: '#4A00E0',
                    radius: 120,
                    power: 1,
                    health: 100,
                    maxHealth: 100,
                    face: "üê∂",
                    active: true,
                    combo: 0,
                    lastComboTime: 0,
                    abilities: ['attract', 'repel', 'vortex']
                },
                {
                    id: 2,
                    x: null,
                    y: null,
                    mode: 'normal',
                    color: '#00F5A0',
                    radius: 120,
                    power: 1,
                    health: 100,
                    maxHealth: 100,
                    face: "üê±",
                    active: false,
                    combo: 0,
                    lastComboTime: 0,
                    abilities: ['shield', 'heal', 'teleport']
                }
            ],
            coopMode: false,
            achievements: {
                particleEater: { unlocked: false, count: 0, required: 50 },
                galaxyExplorer: { unlocked: false, count: 0, required: 3 },
                enemyDestroyer: { unlocked: false, count: 0, required: 100 }
            },
            skills: [
                { id: 'attract_radius', name: "Raio Ampliado", level: 0, max: 5, effect: "Aumenta o raio de atra√ß√£o em 20%", cost: 2, unlocked: true },
                { id: 'vortex_power', name: "V√≥rtice Poderoso", level: 0, max: 3, effect: "Aumenta for√ßa do v√≥rtice em 30%", cost: 3 },
                { id: 'double_vortex', name: "V√≥rtice Duplo", level: 0, max: 1, effect: "Cria um segundo v√≥rtice", cost: 5 },
                { id: 'health_boost', name: "Vitalidade", level: 0, max: 3, effect: "Aumenta vida m√°xima em 15%", cost: 2 },
                { id: 'bigbang_power', name: "Big Bang+", level: 0, max: 2, effect: "Aumenta poder do Big Bang", cost: 4 }
            ],
            currentMission: null,
            missionProgress: 0,
            wave: {
                number: 1,
                enemiesToSpawn: 5,
                spawned: 0,
                timer: 0
            },
            particlesAbsorbed: 0,
            enemiesDestroyed: 0,
            gameTime: 0,
            isMobile: /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)
        };

        // Sistema de fila de mensagens
        const messageQueue = [];
        let isShowingMessage = false;
        let enemies = [];
        let particles = [];
        let powerUpsOnScreen = [];
        const enemyFaces = [">:[", ">:(", "X_X", ">_<", ":O", "‚óâ_‚óâ", "‡≤†_‡≤†", "‚äô_‚äô", "‚âß‚ó°‚â¶", "‚óï‚Äø‚óï"];
        const mouse = { x: null, y: null };

        // Ajuste para dispositivos m√≥veis
        if(config.isMobile) {
            config.particleCount = Math.floor(config.particleCount * 0.6);
        }

        // Inicializa√ß√£o do canvas
        const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d");
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Gal√°xias dispon√≠veis
        const galaxies = {
            classica: {
                name: "Cl√°ssica",
                description: "F√≠sica newtoniana tradicional",
                unlocked: true,
                color: "#4A00E0",
                icon: "üåå",
                init: function() {
                    config.particleCount = 200;
                    if(config.isMobile) config.particleCount = 120;
                    initParticles();
                    
                    particles.forEach(p => {
                        p.behavior = 'normal';
                        p.size = Math.random() * 4 + 2;
                    });
                }
            },
            
            quantica: {
                name: "Qu√¢ntica",
                description: "Part√≠culas que teletransportam e se duplicam",
                unlocked: false,
                requirement: "N√≠vel 3",
                color: "#00F5A0",
                icon: "‚öõÔ∏è",
                init: function() {
                    config.particleCount = 150;
                    if(config.isMobile) config.particleCount = 90;
                    initParticles();
                    
                    particles.forEach(p => {
                        p.behavior = 'quantum';
                        p.size = Math.random() * 3 + 1;
                        p.teleportTimer = Math.random() * 100;
                    });
                }
            },
            
            eletrica: {
                name: "El√©trica",
                description: "Part√≠culas com carga positiva/negativa",
                unlocked: false,
                requirement: "N√≠vel 2",
                color: "#FFD700",
                icon: "‚ö°",
                init: function() {
                    config.particleCount = 180;
                    if(config.isMobile) config.particleCount = 100;
                    initParticles();
                    
                    particles.forEach(p => {
                        p.behavior = 'electric';
                        p.charge = Math.random() > 0.5 ? 1 : -1;
                        p.size = Math.random() * 3 + 2;
                        p.color = p.charge > 0 ? 
                            `hsl(${Math.random() * 60 + 200}, 80%, 60%)` : 
                            `hsl(${Math.random() * 60 + 0}, 80%, 60%)`;
                    });
                }
            },
            
            gravitacional: {
                name: "Gravitacional",
                description: "Buracos negros e distor√ß√µes espaciais",
                unlocked: false,
                requirement: "N√≠vel 5",
                color: "#FF00FF",
                icon: "üï≥Ô∏è",
                init: function() {
                    config.particleCount = 120;
                    if(config.isMobile) config.particleCount = 70;
                    initParticles();
                    
                    // Cria alguns buracos negros naturais
                    for(let i = 0; i < 3; i++) {
                        particles.push({
                            x: Math.random() * canvas.width,
                            y: Math.random() * canvas.height,
                            size: 15 + Math.random() * 20,
                            behavior: 'blackhole',
                            color: 'rgba(0,0,0,0)',
                            isBlackHole: true
                        });
                    }
                    
                    particles.forEach(p => {
                        if(!p.isBlackHole) {
                            p.behavior = 'gravitational';
                            p.size = Math.random() * 2 + 1;
                            p.color = `hsl(${Math.random() * 360}, 70%, 70%)`;
                        }
                    });
                }
            },
            
            caotica: {
                name: "C√°otica",
                description: "F√≠sica imprevis√≠vel e mutante",
                unlocked: false,
                requirement: "N√≠vel 7",
                color: "#FF4500",
                icon: "üåã",
                init: function() {
                    config.particleCount = 250;
                    if(config.isMobile) config.particleCount = 150;
                    initParticles();
                    
                    particles.forEach(p => {
                        p.behavior = 'chaotic';
                        p.size = Math.random() * 5 + 1;
                        p.color = `hsl(${Math.random() * 360}, 100%, 50%)`;
                        p.chaosTimer = Math.random() * 200;
                    });
                }
            },
            
            biologica: {
                name: "Biol√≥gica",
                description: "Part√≠culas que crescem e se reproduzem",
                unlocked: false,
                requirement: "N√≠vel 10",
                color: "#00FF7F",
                icon: "üß¨",
                init: function() {
                    config.particleCount = 100;
                    if(config.isMobile) config.particleCount = 60;
                    initParticles();
                    
                    particles.forEach(p => {
                        p.behavior = 'biological';
                        p.size = Math.random() * 3 + 2;
                        p.color = `hsl(${Math.random() * 60 + 100}, 80%, 60%)`;
                        p.growth = 0;
                        p.energy = 100;
                    });
                }
            }
        };

        // Inicializa√ß√£o das part√≠culas
        function initParticles() {
            particles = [];
            for (let i = 0; i < config.particleCount; i++) {
                particles.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: Math.random() * 4 + 2,
                    color: `hsl(${Math.random() * 360}, 80%, 60%)`,
                    speedX: (Math.random() - 0.5) * 3,
                    speedY: (Math.random() - 0.5) * 3,
                    baseSpeedX: (Math.random() - 0.5) * 3,
                    baseSpeedY: (Math.random() - 0.5) * 3,
                    trail: []
                });
            }
        }

        // Fun√ß√£o para for√ßar aparecimento de part√≠culas e inimigos
        function forceSpawn() {
            if (particles.length < config.particleCount * 0.5) {
                const needed = config.particleCount - particles.length;
                for (let i = 0; i < needed; i++) {
                    particles.push({
                        x: Math.random() * (canvas.width - 100) + 50,
                        y: Math.random() * (canvas.height - 100) + 50,
                        size: Math.random() * 4 + 2,
                        color: `hsl(${Math.random() * 360}, 80%, 60%)`,
                        speedX: (Math.random() - 0.5) * 3,
                        speedY: (Math.random() - 0.5) * 3,
                        baseSpeedX: (Math.random() - 0.5) * 3,
                        baseSpeedY: (Math.random() - 0.5) * 3,
                        trail: []
                    });
                }
            }

            if (enemies.length < 3 && config.wave.spawned < config.wave.enemiesToSpawn) {
                spawnEnemy();
            }
        }

        // Menu Hamburguer
        const menuToggle = document.getElementById('menu-toggle');
        const menu = document.getElementById('menu');

        menuToggle.addEventListener('click', (e) => {
            e.stopPropagation();
            menu.style.display = menu.style.display === 'block' ? 'none' : 'block';
        });

        // Fechar menu ao clicar fora
        document.addEventListener('click', (e) => {
            if (!menu.contains(e.target) && e.target !== menuToggle && e.target !== document.getElementById('bigbang-btn')) {
                menu.style.display = 'none';
            }
        });

        // Controles do menu
        document.getElementById('menu-coop').addEventListener('click', toggleCoopMode);
        document.getElementById('menu-show-galaxies').addEventListener('click', showGalaxyMap);
        document.getElementById('menu-reset').addEventListener('click', resetGame);

        document.getElementById('menu-attract').addEventListener('click', () => {
            config.players[0].mode = 'attract';
            updateMenuButtons();
            menu.style.display = 'none';
        });

        document.getElementById('menu-repel').addEventListener('click', () => {
            config.players[0].mode = 'repel';
            updateMenuButtons();
            menu.style.display = 'none';
        });

        document.getElementById('menu-vortex').addEventListener('click', () => {
            config.players[0].mode = 'vortex';
            updateMenuButtons();
            menu.style.display = 'none';
        });

        document.getElementById('menu-normal').addEventListener('click', () => {
            config.players[0].mode = 'normal';
            updateMenuButtons();
            menu.style.display = 'none';
        });

        // Bot√£o Big Bang
        document.getElementById('bigbang-btn').addEventListener('click', activateBigBang);

        // Controles mobile
        document.getElementById("mobileAttract").addEventListener('click', () => {
            config.players[0].mode = 'attract';
            updateMenuButtons();
        });

        document.getElementById("mobileRepel").addEventListener('click', () => {
            config.players[0].mode = 'repel';
            updateMenuButtons();
        });

        document.getElementById("mobileVortex").addEventListener('click', () => {
            config.players[0].mode = 'vortex';
            updateMenuButtons();
        });

        // Controles jogador 2
        document.getElementById("mobileShieldP2").addEventListener('click', () => {
            if (config.coopMode && config.players[1].abilities.includes('shield')) {
                config.players[1].mode = 'shield';
                activateShield();
                config.players[1].abilities = config.players[1].abilities.filter(a => a !== 'shield');
            }
        });

        document.getElementById("mobileHealP2").addEventListener('click', () => {
            if (config.coopMode && config.players[1].abilities.includes('heal')) {
                config.players[1].mode = 'heal';
                activateHeal();
            }
        });

        document.getElementById("mobileTeleportP2").addEventListener('click', () => {
            if (config.coopMode && config.players[1].abilities.includes('teleport')) {
                config.players[1].mode = 'teleport';
                setTimeout(() => activateTeleport(), 100);
            }
        });

        // Mouse e toques
        canvas.addEventListener('mousemove', (e) => {
            mouse.x = e.clientX;
            mouse.y = e.clientY;
            
            if(!config.coopMode) {
                config.players[0].x = e.clientX;
                config.players[0].y = e.clientY;
            } else {
                config.players[0].x = e.clientX;
                config.players[0].y = e.clientY;
            }
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if(e.touches.length === 1) {
                mouse.x = e.touches[0].clientX;
                mouse.y = e.touches[0].clientY;
                config.players[0].x = e.touches[0].clientX;
                config.players[0].y = e.touches[0].clientY;
            } else if(e.touches.length === 2 && config.coopMode) {
                mouse.x = e.touches[0].clientX;
                mouse.y = e.touches[0].clientY;
                config.players[0].x = e.touches[0].clientX;
                config.players[0].y = e.touches[0].clientY;
                config.players[1].x = e.touches[1].clientX;
                config.players[1].y = e.touches[1].clientY;
            }
        });

        // Sistema de Gal√°xias
        function renderGalaxyMap() {
            const container = document.getElementById('galaxies-list');
            container.innerHTML = '';

            for (const [id, galaxy] of Object.entries(galaxies)) {
                const galaxyElement = document.createElement('div');
                galaxyElement.className = `galaxy ${galaxy.unlocked ? 'unlocked' : 'locked'}`;
                galaxyElement.style.borderColor = galaxy.color;
                galaxyElement.innerHTML = `
                    <div style="font-size: 24px; color: ${galaxy.color}">${galaxy.icon}</div>
                    <h3 style="color: ${galaxy.color}">${galaxy.name}</h3>
                    <p>${galaxy.description}</p>
                    ${!galaxy.unlocked ? `<small>Requer: ${galaxy.requirement}</small>` : ''}
                `;

                if (galaxy.unlocked) {
                    galaxyElement.addEventListener('click', () => {
                        config.galaxies.current = id;
                        galaxies[id].init();
                        document.getElementById('galaxy-map').style.display = 'none';
                        
                        // Atualiza o tema visual
                        document.body.style.background = `
                            radial-gradient(ellipse at bottom, 
                            ${darkenColor(galaxy.color, 70)} 0%, 
                            ${darkenColor(galaxy.color, 90)} 100%)
                        `;
                        
                        showUnlockMessage(`Gal√°xia ${galaxy.name} ativada!`);
                    });
                }

                container.appendChild(galaxyElement);
            }
        }

        function darkenColor(color, percent) {
            // Converte hex para RGB
            let r = parseInt(color.substring(1,3), 16);
            let g = parseInt(color.substring(3,5), 16);
            let b = parseInt(color.substring(5,7), 16);

            // Escurece a cor
            r = Math.floor(r * (100 - percent) / 100);
            g = Math.floor(g * (100 - percent) / 100);
            b = Math.floor(b * (100 - percent) / 100);

            return `rgb(${r},${g},${b})`;
        }

        document.getElementById("close-galaxy-map").addEventListener('click', () => {
            document.getElementById('galaxy-map').style.display = 'none';
        });

        // INIMIGOS
        function spawnEnemy() {
            // Verifica se √© um boss (a cada 10 n√≠veis)
            const isBoss = config.level > 1 && config.level % 10 === 0 && 
                          config.wave.number === 1 && config.wave.spawned === 0;
            
            const isElite = Math.random() < 0.15;
            const isBlackHole = config.level > 3 && Math.random() < 0.05 && !isBoss;
            
            // Tamanhos base
            let sizeBase;
            if (isBoss) sizeBase = 60;
            else if (isBlackHole) sizeBase = 40;
            else if (isElite) sizeBase = 30;
            else sizeBase = 20;
            
            // Comportamento de movimento
            let movementType;
            const movementOptions = ['horizontal', 'vertical', 'diagonal', 'bounce'];
            if (isBoss) {
                movementType = 'boss';
            } else {
                movementType = movementOptions[Math.floor(Math.random() * movementOptions.length)];
            }

            const enemy = {
                x: Math.random() * (canvas.width - sizeBase) + sizeBase/2,
                y: Math.random() * (canvas.height - sizeBase) + sizeBase/2,
                size: sizeBase * (1 + config.level * 0.03),
                speedX: (Math.random() - 0.5) * (3 + config.level * 0.3),
                speedY: (Math.random() - 0.5) * (3 + config.level * 0.3),
                health: (isBoss ? 50 : (isBlackHole ? 15 : (isElite ? 8 : 3))) + config.level * (isBoss ? 5 : (isBlackHole ? 2 : 1)),
                maxHealth: (isBoss ? 50 : (isBlackHole ? 15 : (isElite ? 8 : 3))) + config.level * (isBoss ? 5 : (isBlackHole ? 2 : 1)),
                face: isBoss ? "(‚ï¨‡≤†Áõä‡≤†)" : enemyFaces[Math.floor(Math.random() * enemyFaces.length)],
                type: isBoss ? 'boss' : (isBlackHole ? 'blackhole' : (isElite ? 'elite' : 'normal')),
                damage: isBoss ? 2 : (isBlackHole ? 1 : (isElite ? 0.7 : 0.5)),
                movement: movementType,
                originalSpeedX: 0,
                originalSpeedY: 0
            };

            // Define padr√µes de movimento espec√≠ficos
            switch(enemy.movement) {
                case 'horizontal':
                    enemy.speedX = (Math.random() > 0.5 ? 1 : -1) * (3 + config.level * 0.2);
                    enemy.speedY = 0;
                    break;
                case 'vertical':
                    enemy.speedX = 0;
                    enemy.speedY = (Math.random() > 0.5 ? 1 : -1) * (3 + config.level * 0.2);
                    break;
                case 'diagonal':
                    enemy.speedX = (Math.random() > 0.5 ? 1 : -1) * (2 + config.level * 0.15);
                    enemy.speedY = (Math.random() > 0.5 ? 1 : -1) * (2 + config.level * 0.15);
                    break;
                case 'bounce':
                    enemy.speedX = (Math.random() - 0.5) * (4 + config.level * 0.2);
                    enemy.speedY = (Math.random() - 0.5) * (4 + config.level * 0.2);
                    break;
                case 'boss':
                    enemy.speedX = (Math.random() - 0.5) * (2 + config.level * 0.1);
                    enemy.speedY = (Math.random() - 0.5) * (2 + config.level * 0.1);
                    break;
            }

            enemy.originalSpeedX = enemy.speedX;
            enemy.originalSpeedY = enemy.speedY;

            enemies.push(enemy);
            config.wave.spawned++;

            // Mostra mensagem especial para chefes
            if (isBoss) {
                showUnlockMessage(`CHEF√ÉO NIVEL ${config.level} APARECEU!`);
            }
        }

        function updateEnemies() {
            enemies.forEach((enemy, index) => {
                // Atualiza posi√ß√£o baseada no tipo de movimento
                switch(enemy.movement) {
                    case 'horizontal':
                        enemy.x += enemy.speedX;
                        if (enemy.x < enemy.size/2 || enemy.x > canvas.width - enemy.size/2) {
                            enemy.speedX *= -1;
                            enemy.x = Math.max(enemy.size/2, Math.min(canvas.width - enemy.size/2, enemy.x));
                        }
                        break;
                        
                    case 'vertical':
                        enemy.y += enemy.speedY;
                        if (enemy.y < enemy.size/2 || enemy.y > canvas.height - enemy.size/2) {
                            enemy.speedY *= -1;
                            enemy.y = Math.max(enemy.size/2, Math.min(canvas.height - enemy.size/2, enemy.y));
                        }
                        break;
                        
                    case 'diagonal':
                        enemy.x += enemy.speedX;
                        enemy.y += enemy.speedY;
                        
                        if (enemy.x < enemy.size/2 || enemy.x > canvas.width - enemy.size/2) {
                            enemy.speedX *= -1;
                            enemy.x = Math.max(enemy.size/2, Math.min(canvas.width - enemy.size/2, enemy.x));
                        }
                        
                        if (enemy.y < enemy.size/2 || enemy.y > canvas.height - enemy.size/2) {
                            enemy.speedY *= -1;
                            enemy.y = Math.max(enemy.size/2, Math.min(canvas.height - enemy.size/2, enemy.y));
                        }
                        break;
                        
                    case 'bounce':
                        enemy.x += enemy.speedX;
                        enemy.y += enemy.speedY;
                        
                        if (enemy.x < enemy.size/2 || enemy.x > canvas.width - enemy.size/2) {
                            enemy.speedX *= -0.9;
                            enemy.x = Math.max(enemy.size/2, Math.min(canvas.width - enemy.size/2, enemy.x));
                        }
                        
                        if (enemy.y < enemy.size/2 || enemy.y > canvas.height - enemy.size/2) {
                            enemy.speedY *= -0.9;
                            enemy.y = Math.max(enemy.size/2, Math.min(canvas.height - enemy.size/2, enemy.y));
                        }
                        
                        // Reduz velocidade gradualmente
                        enemy.speedX *= 0.999;
                        enemy.speedY *= 0.999;
                        
                        // Se ficar muito lento, volta √† velocidade original
                        if (Math.abs(enemy.speedX) < 0.5) enemy.speedX = enemy.originalSpeedX;
                        if (Math.abs(enemy.speedY) < 0.5) enemy.speedY = enemy.originalSpeedY;
                        break;
                        
                    case 'boss':
                        // Movimento semi-aleat√≥rio para chefes
                        enemy.x += enemy.speedX;
                        enemy.y += enemy.speedY;
                        
                        if (enemy.x < enemy.size/2 || enemy.x > canvas.width - enemy.size/2) {
                            enemy.speedX *= -1;
                            enemy.x = Math.max(enemy.size/2, Math.min(canvas.width - enemy.size/2, enemy.x));
                        }
                        
                        if (enemy.y < enemy.size/2 || enemy.y > canvas.height - enemy.size/2) {
                            enemy.speedY *= -1;
                            enemy.y = Math.max(enemy.size/2, Math.min(canvas.height - enemy.size/2, enemy.y));
                        }
                        
                        // Muda dire√ß√£o ocasionalmente
                        if (Math.random() < 0.01) {
                            enemy.speedX = (Math.random() - 0.5) * (2 + config.level * 0.1);
                            enemy.speedY = (Math.random() - 0.5) * (2 + config.level * 0.1);
                        }
                        break;
                }

                // Comportamento especial para buracos negros
                if (enemy.type === 'blackhole') {
                    particles.forEach(p => {
                        const dx = enemy.x - p.x;
                        const dy = enemy.y - p.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if(distance < enemy.size * 2) {
                            const force = (enemy.size * 2 - distance) / (enemy.size * 2);
                            const angle = Math.atan2(dy, dx);
                            p.speedX += Math.cos(angle) * force * 0.5;
                            p.speedY += Math.sin(angle) * force * 0.5;

                            if(distance < enemy.size * 0.5) {
                                particles.splice(particles.indexOf(p), 1);
                            }
                        }
                    });
                }

                // Verifica√ß√£o de colis√£o com jogadores
                config.players.forEach(player => {
                    if(player.active && player.x && player.y) {
                        const dx = player.x - enemy.x;
                        const dy = player.y - enemy.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance < enemy.size/2 + 15) {
                            // Verifica se o jogador 2 tem escudo ativo
                            const shieldProtection = config.players[1].shieldActive ? 0.3 : 1;
                            player.health -= enemy.damage * (config.coopMode ? 0.7 : 1) * shieldProtection;
                            updateHealthBar();

                            if(player.id === 1) {
                                document.body.style.boxShadow = 'inset 0 0 30px red';
                                setTimeout(() => {
                                    document.body.style.boxShadow = 'none';
                                }, 100);
                            }
                        }
                    }
                });

                // Verifica√ß√£o de colis√£o com part√≠culas
                particles.forEach(particle => {
                    const dx = enemy.x - particle.x;
                    const dy = enemy.y - particle.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const minDist = enemy.size/2 + particle.size/2;

                    if (distance < minDist) {
                        enemy.health -= 0.05;
                        const angle = Math.atan2(dy, dx);
                        const force = (minDist - distance) * 0.1;
                        particle.speedX = -Math.cos(angle) * force * 3;
                        particle.speedY = -Math.sin(angle) * force * 3;
                    }
                });

                if (enemy.health <= 0) {
                    createExplosion(enemy.x, enemy.y, enemy.size);
                    enemies.splice(index, 1);

                    const xpValue = enemy.type === 'boss' ? 200 : 
                                   enemy.type === 'elite' ? 25 : 
                                   enemy.type === 'blackhole' ? 50 : 10;
                    addXP(xpValue * (config.coopMode ? 0.8 : 1));

                    config.enemiesDestroyed++;
                    if(!config.achievements.enemyDestroyer.unlocked && 
                       config.enemiesDestroyed >= config.achievements.enemyDestroyer.required) {
                        config.achievements.enemyDestroyer.unlocked = true;
                        showUnlockMessage("Conquista: Destruidor de Inimigos!");
                        addXP(100);
                    }

                    // Drop de power-up para chefes
                    if (enemy.type === 'boss') {
                        spawnPowerUp(enemy.x, enemy.y);
                    }
                }
            });
        }

        function createExplosion(x, y, size) {
            for (let i = 0; i < 15; i++) {
                particles.push({
                    x: x,
                    y: y,
                    size: Math.random() * 3 + 1,
                    color: `hsl(${Math.random() * 60}, 100%, 50%)`,
                    speedX: (Math.random() - 0.5) * 10,
                    speedY: (Math.random() - 0.5) * 10,
                    baseSpeedX: 0,
                    baseSpeedY: 0,
                    life: 100 + Math.random() * 50,
                    trail: []
                });
            }
        }

        function drawEnemies() {
            enemies.forEach(enemy => {
                ctx.save();
                
                // Efeito especial para chefes
                if (enemy.type === 'boss') {
                    ctx.shadowColor = 'rgba(255, 0, 255, 0.7)';
                    ctx.shadowBlur = 30;
                }
                
                ctx.beginPath();
                ctx.arc(enemy.x, enemy.y, enemy.size, 0, Math.PI * 2);
                
                // Preenchimento baseado no tipo
                if (enemy.type === 'boss') {
                    const gradient = ctx.createRadialGradient(
                        enemy.x, enemy.y, enemy.size * 0.3,
                        enemy.x, enemy.y, enemy.size
                    );
                    gradient.addColorStop(0, 'rgba(200, 0, 255, 0.9)');
                    gradient.addColorStop(1, 'rgba(50, 0, 150, 0.8)');
                    ctx.fillStyle = gradient;
                } else if (enemy.type === 'blackhole') {
                    const gradient = ctx.createRadialGradient(
                        enemy.x, enemy.y, enemy.size * 0.1,
                        enemy.x, enemy.y, enemy.size
                    );
                    gradient.addColorStop(0, 'rgba(0, 0, 0, 0.9)');
                    gradient.addColorStop(0.7, 'rgba(70, 0, 120, 0.8)');
                    gradient.addColorStop(1, 'rgba(150, 0, 0, 0.8)');
                    ctx.fillStyle = gradient;
                } else if (enemy.type === 'elite') {
                    const gradient = ctx.createRadialGradient(
                        enemy.x, enemy.y, enemy.size * 0.3,
                        enemy.x, enemy.y, enemy.size
                    );
                    gradient.addColorStop(0, 'rgba(255, 215, 0, 0.9)');
                    gradient.addColorStop(1, 'rgba(255, 100, 0, 0.8)');
                    ctx.fillStyle = gradient;
                } else {
                    const gradient = ctx.createRadialGradient(
                        enemy.x, enemy.y, enemy.size * 0.3,
                        enemy.x, enemy.y, enemy.size
                    );
                    gradient.addColorStop(0, 'rgba(255, 100, 100, 0.8)');
                    gradient.addColorStop(1, 'rgba(150, 0, 0, 0.8)');
                    ctx.fillStyle = gradient;
                }
                
                ctx.fill();
                
                // Desenha o rosto do inimigo
                ctx.font = `${enemy.size/2}px monospace`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                if (enemy.type === 'boss') {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.shadowColor = 'rgba(255, 255, 255, 0.7)';
                    ctx.shadowBlur = 10;
                } else if (enemy.type === 'elite') {
                    ctx.fillStyle = 'gold';
                } else if (enemy.type === 'blackhole') {
                    ctx.fillStyle = '#8A2BE2';
                } else {
                    ctx.fillStyle = 'white';
                }
                
                ctx.fillText(enemy.face, enemy.x, enemy.y + (enemy.size * 0.05));
                
                // Barra de vida
                const healthBarWidth = enemy.size * 1.5;
                const healthPercent = enemy.health / enemy.maxHealth;
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(
                    enemy.x - healthBarWidth/2, 
                    enemy.y - enemy.size - 15, 
                    healthBarWidth, 
                    8
                );
                
                ctx.fillStyle = enemy.type === 'boss' ? '#FF00FF' : 
                               `hsl(${healthPercent * 120}, 100%, 50%)`;
                ctx.fillRect(
                    enemy.x - healthBarWidth/2, 
                    enemy.y - enemy.size - 15, 
                    healthBarWidth * healthPercent, 
                    8
                );
                
                ctx.restore();
                
                // Efeito especial para buracos negros
                if (enemy.type === 'blackhole') {
                    ctx.strokeStyle = 'rgba(100, 0, 255, 0.7)';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(enemy.x, enemy.y, enemy.size * 1.5, 0, Math.PI * 2);
                    ctx.stroke();
                }
            });
        }

        // BIG BANG
        function activateBigBang() {
            // S√≥ pode ser usado a cada 15 n√≠veis
            if (config.level < 15 || config.bigBangCooldown > 0 || config.isBigBangActive) {
                return;
            }

            config.isBigBangActive = true;
            
            // Mostra mensagem antes do efeito
            const message = document.createElement('div');
            message.className = 'universe-restart-message';
            message.textContent = 'O Universo ir√° recome√ßar...';
            document.body.appendChild(message);
            
            // Anima√ß√£o da mensagem
            setTimeout(() => {
                message.style.opacity = '1';
            }, 100);
            
            // Efeito visual ap√≥s a mensagem
            setTimeout(() => {
                message.style.opacity = '0';
                
                setTimeout(() => {
                    message.remove();
                    
                    // Efeito Big Bang
                    const bang = document.createElement('div');
                    bang.style.position = 'fixed';
                    bang.style.left = '0';
                    bang.style.top = '0';
                    bang.style.width = '100%';
                    bang.style.height = '100%';
                    bang.style.background = 'radial-gradient(circle, rgba(255,255,255,0.9) 0%, rgba(255,0,255,0) 70%)';
                    bang.style.zIndex = '1000';
                    bang.style.pointerEvents = 'none';
                    bang.style.opacity = '0';
                    bang.style.transition = 'opacity 1s';
                    document.body.appendChild(bang);

                    setTimeout(() => {
                        bang.style.opacity = '1';
                    }, 10);

                    setTimeout(() => {
                        bang.style.opacity = '0';
                        setTimeout(() => bang.remove(), 1000);
                    }, 500);

                    // Efeito nas part√≠culas e inimigos
                    const centerX = mouse.x || canvas.width/2;
                    const centerY = mouse.y || canvas.height/2;
                    const bangPower = 1 + config.skills.find(s => s.id === 'bigbang_power').level * 0.5;

                    // Resetar todos os inimigos
                    enemies = [];

                    // Resetar e recriar part√≠culas com efeito especial
                    particles = [];
                    for (let i = 0; i < config.particleCount * 2; i++) {
                        particles.push({
                            x: centerX,
                            y: centerY,
                            size: Math.random() * 5 + 2,
                            color: `hsl(${Math.random() * 360}, 100%, 70%)`,
                            speedX: (Math.random() - 0.5) * 20 * bangPower,
                            speedY: (Math.random() - 0.5) * 20 * bangPower,
                            baseSpeedX: 0,
                            baseSpeedY: 0,
                            life: 100 + Math.random() * 50,
                            trail: []
                        });
                    }

                    // Resetar cooldown (s√≥ pode usar novamente ap√≥s subir 15 n√≠veis)
                    config.bigBangCooldown = Infinity;
                    document.getElementById('bigbang-btn').classList.remove('ready');
                    
                    setTimeout(() => {
                        config.isBigBangActive = false;
                    }, 2000);
                    
                }, 2000); // Tempo que a mensagem fica vis√≠vel
            }, 500);
        }

        // SISTEMA DE XP E N√çVEL
        function addXP(amount) {
            config.xp += amount * (1 + Math.sqrt(config.level) * 0.15);
            const maxXP = 100 + (config.level * 30);

            if (config.xp >= maxXP) {
                config.xp -= maxXP;
                config.level++;
                config.power += 0.2;
                config.maxHealth += 10;
                config.health = config.maxHealth;
                updateHealthBar();

                // Verifica se Big Bang est√° dispon√≠vel
                if (config.level % 15 === 0) {
                    config.bigBangCooldown = 0;
                    document.getElementById('bigbang-btn').classList.add('ready');
                }

                // Desbloqueia gal√°xias conforme o n√≠vel
                if (config.level >= 2 && !galaxies.eletrica.unlocked) {
                    galaxies.eletrica.unlocked = true;
                    showUnlockMessage("Gal√°xia El√©trica desbloqueada!");
                }
                if (config.level >= 3 && !galaxies.quantica.unlocked) {
                    galaxies.quantica.unlocked = true;
                    showUnlockMessage("Gal√°xia Qu√¢ntica desbloqueada!");
                }
                if (config.level >= 5 && !galaxies.gravitacional.unlocked) {
                    galaxies.gravitacional.unlocked = true;
                    showUnlockMessage("Gal√°xia Gravitacional desbloqueada!");
                }
                if (config.level >= 7 && !galaxies.caotica.unlocked) {
                    galaxies.caotica.unlocked = true;
                    showUnlockMessage("Gal√°xia C√°otica desbloqueada!");
                }
                if (config.level >= 10 && !galaxies.biologica.unlocked) {
                    galaxies.biologica.unlocked = true;
                    showUnlockMessage("Gal√°xia Biol√≥gica desbloqueada!");
                }

                showUnlockMessage(`N√≠vel UP! Agora voc√™ √© n√≠vel ${config.level}`);
            }
            updateXPBar();
        }

        function updateHealthBar() {
            let totalHealth = 0;
            let totalMaxHealth = 0;
            let activePlayers = 0;

            config.players.forEach(player => {
                if(player.active) {
                    totalHealth += Math.max(0, player.health);
                    totalMaxHealth += player.maxHealth;
                    activePlayers++;
                }
            });

            if(activePlayers === 0) return;

            const healthPercent = totalHealth / totalMaxHealth;
            document.getElementById('health-bar').style.width = `${healthPercent * 100}%`;
            document.getElementById('health-bar').style.background = 
                `linear-gradient(90deg, hsl(${healthPercent * 120}, 100%, 50%), hsl(${healthPercent * 120}, 100%, 30%))`;

            if (healthPercent <= 0) {
                setTimeout(() => {
                    alert(`Game Over! Seu n√≠vel: ${config.level}`);
                    resetGameState();
                }, 500);
            }
        }

        function updateXPBar() {
            const maxXP = 100 + (config.level * 30);
            const xpPercent = (config.xp / maxXP) * 100;
            document.getElementById('xp-bar').style.width = `${xpPercent}%`;
            document.getElementById('xp-text').textContent = 
                `${Math.floor(config.xp)}/${maxXP} XP (N√≠vel ${config.level})`;
        }

        function updateBigBangCooldown() {
            if (config.bigBangCooldown > 0) {
                config.bigBangCooldown--;
                const percent = (1 - (config.bigBangCooldown / config.bigBangMaxCooldown)) * 100;
                document.getElementById('bigbang-progress').style.width = `${percent}%`;
            }
        }

        // MODOS DO JOGADOR E HABILIDADES
        function toggleCoopMode() {
            config.coopMode = !config.coopMode;
            config.players[1].active = config.coopMode;

            const coopButton = document.getElementById('menu-coop');
            coopButton.textContent = `üîµ Cooperativo: ${config.coopMode ? 'ON' : 'OFF'}`;

            if(config.isMobile) {
                document.getElementById('mobile-controls-p2').style.display = 
                    config.coopMode ? 'flex' : 'none';
            }

            // Atualiza indicadores de jogador
            document.getElementById('player2-indicator').style.display = 
                config.coopMode ? 'block' : 'none';

            config.players[0].radius = config.coopMode ? 120 : 150;
            config.players[1].radius = 120;

            // Posicionamento inicial do jogador 2
            if(config.coopMode && !config.players[1].x) {
                config.players[1].x = canvas.width / 4;
                config.players[1].y = canvas.height / 2;
            }
        }

        function updateMenuButtons() {
            const modes = ['attract', 'repel', 'vortex', 'normal'];
            const colors = {
                attract: '#8A2BE2',
                repel: '#FF4500',
                vortex: '#00BFFF',
                normal: '#4A00E0'
            };
            
            modes.forEach(mode => {
                const btn = document.getElementById(`menu-${mode}`);
                if(btn) {
                    btn.style.textShadow = config.players[0].mode === mode ? 
                        `0 0 10px ${colors[mode]}` : 'none';
                    btn.style.fontWeight = config.players[0].mode === mode ? 
                        'bold' : 'normal';
                }
            });
        }

        // HABILIDADES DO JOGADOR 2
        function activateShield() {
            if (config.coopMode && config.players[1].mode === 'shield') {
                config.players[1].shieldActive = true;
                config.players[1].shieldTime = 180; // 3 segundos
                
                // Efeito visual
                const shieldEffect = document.createElement('div');
                shieldEffect.className = 'shield-effect';
                shieldEffect.style.cssText = `
                    position: fixed;
                    border-radius: 50%;
                    border: 3px dashed #00F5A0;
                    pointer-events: none;
                    z-index: 999;
                    transform: translate(-50%, -50%);
                    animation: shieldPulse 1s infinite;
                `;
                document.body.appendChild(shieldEffect);
                
                function updateShield() {
                    if (config.players[1].shieldActive && config.players[1].x && config.players[1].y) {
                        const size = config.players[1].radius * 2.5;
                        shieldEffect.style.width = `${size}px`;
                        shieldEffect.style.height = `${size}px`;
                        shieldEffect.style.left = `${config.players[1].x}px`;
                        shieldEffect.style.top = `${config.players[1].y}px`;
                        requestAnimationFrame(updateShield);
                    } else {
                        shieldEffect.remove();
                    }
                }
                updateShield();
                
                setTimeout(() => {
                    config.players[1].shieldActive = false;
                    // Habilidade volta ap√≥s cooldown
                    setTimeout(() => {
                        config.players[1].abilities.push('shield');
                    }, 15000); // 15 segundos de cooldown
                }, 3000);
            }
        }

        function activateHeal() {
            if (config.coopMode && config.players[1].mode === 'heal') {
                const healAmount = 25;
                
                // Cura ambos jogadores
                config.players[0].health = Math.min(config.players[0].maxHealth, config.players[0].health + healAmount);
                config.players[1].health = Math.min(config.players[1].maxHealth, config.players[1].health + healAmount);
                updateHealthBar();
                
                // Efeito visual
                createHealEffect(config.players[1].x, config.players[1].y);
                createHealEffect(config.players[0].x, config.players[0].y);
                
                // Cooldown
                config.players[1].mode = 'normal';
                setTimeout(() => {
                    config.players[1].abilities.push('heal');
                }, 10000); // 10 segundos de cooldown
            }
        }

        function createHealEffect(x, y) {
            const heal = document.createElement('div');
            heal.style.cssText = `
                position: fixed;
                width: 100px;
                height: 100px;
                left: ${x - 50}px;
                top: ${y - 50}px;
                background: radial-gradient(circle, rgba(0,245,160,0.3) 0%, rgba(0,245,160,0) 70%);
                border-radius: 50%;
                pointer-events: none;
                z-index: 998;
                animation: healFade 1.5s forwards;
            `;
            document.body.appendChild(heal);
            
            setTimeout(() => heal.remove(), 1500);
        }

        function activateTeleport() {
            if (config.coopMode && config.players[1].mode === 'teleport' && mouse.x && mouse.y) {
                // Teleporta o jogador 2 para a posi√ß√£o do mouse
                config.players[1].x = mouse.x;
                config.players[1].y = mouse.y;
                
                // Efeito visual
                createTeleportEffect(config.players[1].x, config.players[1].y);
                
                // Cooldown
                config.players[1].mode = 'normal';
                setTimeout(() => {
                    config.players[1].abilities.push('teleport');
                }, 8000); // 8 segundos de cooldown
            }
        }

        function createTeleportEffect(x, y) {
            const teleport = document.createElement('div');
            teleport.style.cssText = `
                position: fixed;
                width: 120px;
                height: 120px;
                left: ${x - 60}px;
                top: ${y - 60}px;
                background: radial-gradient(circle, rgba(0,245,160,0.5) 0%, rgba(0,245,160,0) 70%);
                border-radius: 50%;
                pointer-events: none;
                z-index: 997;
                animation: teleportFade 1s forwards;
            `;
            document.body.appendChild(teleport);
            
            setTimeout(() => teleport.remove(), 1000);
        }

        // SISTEMA DE COMBOS COOPERATIVOS
        function checkCombo() {
            if (!config.coopMode) return;
            
            const now = Date.now();
            const distance = Math.sqrt(
                Math.pow(config.players[0].x - config.players[1].x, 2) + 
                Math.pow(config.players[0].y - config.players[1].y, 2)
            );
            
            // Se os jogadores estiverem pr√≥ximos e usando habilidades complementares
            if (distance < 200) {
                const p1Mode = config.players[0].mode;
                const p2Mode = config.players[1].mode;
                
                // Combos v√°lidos
                const validCombos = [
                    { p1: 'attract', p2: 'repel', effect: 'vortexBoost' },
                    { p1: 'vortex', p2: 'shield', effect: 'blackHole' },
                    { p1: 'repel', p2: 'teleport', effect: 'superNova' }
                ];
                
                const combo = validCombos.find(c => 
                    (c.p1 === p1Mode && c.p2 === p2Mode) || 
                    (c.p1 === p2Mode && c.p2 === p1Mode)
                );
                
                if (combo && now - config.players[0].lastComboTime > 1000) {
                    config.players[0].combo++;
                    config.players[1].combo++;
                    config.players[0].lastComboTime = now;
                    config.players[1].lastComboTime = now;
                    
                    showComboEffect(combo.effect);
                    updateComboDisplay();
                    
                    // Efeitos especiais do combo
                    switch(combo.effect) {
                        case 'vortexBoost':
                            config.players[0].radius += 30;
                            config.players[1].radius += 30;
                            setTimeout(() => {
                                config.players[0].radius -= 30;
                                config.players[1].radius -= 30;
                            }, 5000);
                            break;
                            
                        case 'blackHole':
                            createBlackHole(
                                (config.players[0].x + config.players[1].x) / 2,
                                (config.players[0].y + config.players[1].y) / 2
                            );
                            break;
                            
                        case 'superNova':
                            particles.forEach(p => {
                                p.color = `hsl(${Math.random() * 360}, 100%, 70%)`;
                                p.speedX = (Math.random() - 0.5) * 20;
                                p.speedY = (Math.random() - 0.5) * 20;
                            });
                            break;
                    }
                }
            } else if (now - config.players[0].lastComboTime > 3000) {
                // Reset combo se ficarem muito tempo separados
                if (config.players[0].combo > 0) {
                    config.players[0].combo = 0;
                    config.players[1].combo = 0;
                    updateComboDisplay();
                }
            }
        }

        function showComboEffect(type) {
            const effects = {
                vortexBoost: { text: "V√ìRTICE POTENCIADO!", color: "#8E2DE2" },
                blackHole: { text: "BURACO NEGRO CRIADO!", color: "#000000" },
                superNova: { text: "SUPERNOVA ATIVADA!", color: "#FF8C00" }
            };
            
            const effect = effects[type];
            if (!effect) return;
            
            const comboText = document.createElement('div');
            comboText.className = 'unlock-message';
            comboText.textContent = effect.text;
            comboText.style.color = effect.color;
            comboText.style.borderColor = effect.color;
            comboText.style.boxShadow = `0 0 30px ${effect.color}`;
            
            document.body.appendChild(comboText);
            
            setTimeout(() => {
                comboText.style.opacity = '1';
                comboText.style.transform = 'translate(-50%, -50%) scale(1)';
            }, 10);
            
            setTimeout(() => {
                comboText.style.opacity = '0';
                comboText.style.transform = 'translate(-50%, -50%) scale(0.9)';
                setTimeout(() => comboText.remove(), 500);
            }, 2000);
        }

        function updateComboDisplay() {
            const comboDisplay = document.querySelector('.coop-combo') || document.createElement('div');
            comboDisplay.className = 'coop-combo';
            comboDisplay.innerHTML = `
                COMBO COOPERATIVO! <span class="combo-count">x${config.players[0].combo}</span>
            `;
            
            if (config.players[0].combo > 0) {
                if (!comboDisplay.parentNode) document.body.appendChild(comboDisplay);
                comboDisplay.style.display = 'block';
                
                // Efeito visual baseado no combo count
                const scale = 1 + Math.min(config.players[0].combo * 0.1, 0.5);
                comboDisplay.style.transform = `translateX(-50%) scale(${scale})`;
                comboDisplay.style.background = `rgba(0, 0, 0, ${Math.min(0.8, 0.5 + config.players[0].combo * 0.05)})`;
            } else {
                comboDisplay.style.display = 'none';
            }
        }

        function createBlackHole(x, y) {
            const blackHole = {
                x: x,
                y: y,
                size: 40,
                life: 300, // 5 segundos
                update: function() {
                    this.life--;
                    this.size = 40 + Math.sin(Date.now()/200) * 10;
                    
                    // Atrai part√≠culas
                    particles.forEach(p => {
                        const dx = this.x - p.x;
                        const dy = this.y - p.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < 400) {
                            const force = (400 - distance) / 400 * 2;
                            const angle = Math.atan2(dy, dx);
                            
                            p.speedX += Math.cos(angle) * force;
                            p.speedY += Math.sin(angle) * force;
                            
                            if (distance < this.size) {
                                particles.splice(particles.indexOf(p), 1);
                                addXP(5); // XP por part√≠cula absorvida
                            }
                        }
                    });
                    
                    // Atrai inimigos
                    enemies.forEach(e => {
                        const dx = this.x - e.x;
                        const dy = this.y - e.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < 500) {
                            e.health -= 0.1;
                            const force = (500 - distance) / 500 * 1.5;
                            const angle = Math.atan2(dy, dx);
                            
                            e.speedX += Math.cos(angle) * force;
                            e.speedY += Math.sin(angle) * force;
                        }
                    });
                    
                    return this.life > 0;
                },
                draw: function() {
                    // Gradiente do buraco negro
                    const gradient = ctx.createRadialGradient(
                        this.x, this.y, this.size * 0.1,
                        this.x, this.y, this.size
                    );
                    gradient.addColorStop(0, 'rgba(0,0,0,0.9)');
                    gradient.addColorStop(0.7, 'rgba(70,0,120,0.8)');
                    gradient.addColorStop(1, 'rgba(150,0,0,0.5)');
                    
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Anel exterior
                    ctx.strokeStyle = 'rgba(100,0,255,0.7)';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size * 1.5, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Disco de acre√ß√£o
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size * 1.2, 0, Math.PI * 2);
                    ctx.strokeStyle = 'rgba(255,255,255,0.3)';
                    ctx.lineWidth = 8;
                    ctx.stroke();
                }
            };
            
            // Adiciona √† lista de efeitos especiais
            if (!window.specialEffects) window.specialEffects = [];
            window.specialEffects.push(blackHole);
        }

        // POWER-UPS
        function spawnPowerUp(x, y) {
            const powerUps = ['health', 'xp', 'radius', 'vortex'];
            const type = powerUps[Math.floor(Math.random() * powerUps.length)];
            
            const powerUp = {
                x: x,
                y: y,
                size: 20,
                type: type,
                color: type === 'health' ? '#FF5555' : 
                      type === 'xp' ? '#55FF55' : 
                      type === 'radius' ? '#5555FF' : '#FF55FF',
                life: 300, // 5 segundos (60fps * 5)
                symbol: type === 'health' ? '‚ù§Ô∏è' : 
                       type === 'xp' ? '‚ú®' : 
                       type === 'radius' ? 'üîµ' : 'üåÄ'
            };
            
            powerUpsOnScreen.push(powerUp);
        }

        function updatePowerUps() {
            for (let i = powerUpsOnScreen.length - 1; i >= 0; i--) {
                const p = powerUpsOnScreen[i];
                p.life--;
                
                // Verifica colis√£o com jogadores
                config.players.forEach(player => {
                    if (player.active && player.x && player.y) {
                        const dx = player.x - p.x;
                        const dy = player.y - p.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < p.size + 15) {
                            // Aplica efeito do power-up
                            switch(p.type) {
                                case 'health':
                                    player.health = Math.min(player.maxHealth, player.health + 30);
                                    updateHealthBar();
                                    break;
                                case 'xp':
                                    addXP(50);
                                    break;
                                case 'radius':
                                    player.radius += 20;
                                    setTimeout(() => {
                                        player.radius -= 20;
                                    }, 10000);
                                    break;
                                case 'vortex':
                                    if (player.id === 1) {
                                        player.mode = 'vortex';
                                        setTimeout(() => {
                                            player.mode = 'normal';
                                        }, 5000);
                                    }
                                    break;
                            }
                            
                            powerUpsOnScreen.splice(i, 1);
                            return;
                        }
                    }
                });
                
                // Remove power-up se o tempo acabar
                if (p.life <= 0) {
                    powerUpsOnScreen.splice(i, 1);
                }
            }
        }

        function drawPowerUps() {
            powerUpsOnScreen.forEach(p => {
                // Desenha o power-up
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fillStyle = p.color + '80';
                ctx.fill();
                
                ctx.strokeStyle = p.color;
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Desenha o s√≠mbolo
                ctx.font = `${p.size}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillStyle = 'white';
                ctx.fillText(p.symbol, p.x, p.y);
                
                // Desenha o timer
                const timerWidth = p.size * 2;
                const timerPercent = p.life / 300;
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(
                    p.x - timerWidth/2, 
                    p.y + p.size + 5, 
                    timerWidth, 
                    5
                );
                
                ctx.fillStyle = p.color;
                ctx.fillRect(
                    p.x - timerWidth/2, 
                    p.y + p.size + 5, 
                    timerWidth * timerPercent, 
                    5
                );
            });
        }

        // COMPORTAMENTO DAS PART√çCULAS
        function updateParticleBehavior(particle) {
            switch(particle.behavior) {
                case 'quantum':
                    // Teletransporte qu√¢ntico
                    particle.teleportTimer--;
                    if(particle.teleportTimer <= 0) {
                        particle.x = Math.random() * canvas.width;
                        particle.y = Math.random() * canvas.height;
                        particle.teleportTimer = 50 + Math.random() * 100;
                        
                        // 10% de chance de se duplicar
                        if(Math.random() < 0.1 && particles.length < config.particleCount * 1.5) {
                            particles.push({
                                ...JSON.parse(JSON.stringify(particle)),
                                teleportTimer: 100 + Math.random() * 100
                            });
                        }
                    }
                    break;
                    
                case 'electric':
                    // Atra√ß√£o/repuls√£o el√©trica
                    particles.forEach(other => {
                        if(other !== particle && other.behavior === 'electric') {
                            const dx = other.x - particle.x;
                            const dy = other.y - particle.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            
                            if(distance < 150) {
                                const force = (particle.charge * other.charge) / (distance * distance) * 5;
                                const angle = Math.atan2(dy, dx);
                                
                                particle.speedX += Math.cos(angle) * force * (particle.charge > 0 ? 1 : -1);
                                particle.speedY += Math.sin(angle) * force * (particle.charge > 0 ? 1 : -1);
                            }
                        }
                    });
                    break;
                    
                case 'gravitational':
                    // Atra√ß√£o gravitacional para buracos negros
                    particles.forEach(other => {
                        if(other.isBlackHole) {
                            const dx = other.x - particle.x;
                            const dy = other.y - particle.y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            
                            if(distance < 300) {
                                const force = (other.size * 10) / (distance * distance);
                                const angle = Math.atan2(dy, dx);
                                
                                particle.speedX += Math.cos(angle) * force;
                                particle.speedY += Math.sin(angle) * force;
                                
                                if(distance < other.size) {
                                    particle.x = Math.random() * canvas.width;
                                    particle.y = Math.random() * canvas.height;
                                }
                            }
                        }
                    });
                    break;
                    
                case 'chaotic':
                    // Comportamento ca√≥tico mutante
                    particle.chaosTimer--;
                    if(particle.chaosTimer <= 0) {
                        particle.speedX = (Math.random() - 0.5) * 10;
                        particle.speedY = (Math.random() - 0.5) * 10;
                        particle.chaosTimer = 50 + Math.random() * 150;
                        
                        // Muda de cor aleatoriamente
                        particle.color = `hsl(${Math.random() * 360}, 100%, 50%)`;
                    }
                    break;
                    
                case 'biological':
                    // Crescimento e reprodu√ß√£o
                    particle.growth += 0.01;
                    particle.energy -= 0.05;
                    
                    if(particle.growth > 10 && particle.energy > 50 && 
                       particles.length < config.particleCount * 1.3) {
                        particle.growth = 0;
                        particle.energy -= 30;
                        
                        // Reproduz
                        particles.push({
                            x: particle.x + (Math.random() - 0.5) * 20,
                            y: particle.y + (Math.random() - 0.5) * 20,
                            size: Math.random() * 3 + 1,
                            behavior: 'biological',
                            color: `hsl(${(parseInt(particle.color.split(',')[0].split('(')[1]) + 
                                    Math.random() * 40 - 20) % 360}, 80%, 60%)`,
                            growth: 0,
                            energy: 80 + Math.random() * 40,
                            speedX: (Math.random() - 0.5) * 2,
                            speedY: (Math.random() - 0.5) * 2
                        });
                    }
                    
                    // Morte por falta de energia
                    if(particle.energy <= 0) {
                        particle.size *= 0.98;
                        if(particle.size < 0.5) {
                            particles.splice(particles.indexOf(particle), 1);
                        }
                    } else {
                        particle.size = 2 + Math.sin(particle.growth) * 3;
                    }
                    break;
            }
        }

        // DESENHO DOS JOGADORES
        function drawPlayers() {
            config.players.forEach(player => {
                if(!player.active || !player.x || !player.y) return;

                ctx.save();
                
                switch(player.mode) {
                    case 'attract': 
                        // Buraco negro que atrai part√≠culas
                        const gradient = ctx.createRadialGradient(
                            player.x, player.y, 5,
                            player.x, player.y, player.radius
                        );
                        gradient.addColorStop(0, 'rgba(0,0,0,0.9)');
                        gradient.addColorStop(0.7, 'rgba(70,0,120,0.8)');
                        gradient.addColorStop(1, 'rgba(150,0,0,0)');
                        
                        ctx.beginPath();
                        ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
                        ctx.fillStyle = gradient;
                        ctx.fill();
                        
                        ctx.font = `${Math.min(40, player.radius/3)}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillStyle = 'white';
                        ctx.fillText('üåÄ', player.x, player.y);
                        
                        // Efeito de distor√ß√£o
                        if (Date.now() % 1000 < 500) {
                            ctx.strokeStyle = 'rgba(100,0,255,0.5)';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.arc(player.x, player.y, player.radius * 0.8, 0, Math.PI * 2);
                            ctx.stroke();
                        }
                        break;
                        
                    case 'repel': 
                        // Explos√£o/energia repelindo part√≠culas
                        const explosionGradient = ctx.createRadialGradient(
                            player.x, player.y, 5,
                            player.x, player.y, player.radius
                        );
                        explosionGradient.addColorStop(0, 'rgba(255,100,0,0.9)');
                        explosionGradient.addColorStop(0.5, 'rgba(255,200,0,0.5)');
                        explosionGradient.addColorStop(1, 'rgba(255,50,0,0)');
                        
                        ctx.beginPath();
                        ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
                        ctx.fillStyle = explosionGradient;
                        ctx.fill();
                        
                        // √çcone de explos√£o com anima√ß√£o
                        const pulseSize = 1 + Math.sin(Date.now()/200) * 0.2;
                        ctx.font = `${Math.min(40, player.radius/3) * pulseSize}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillStyle = 'rgba(255,255,255,0.9)';
                        ctx.fillText('üí•', player.x, player.y);
                        
                        // Raios de energia
                        for (let i = 0; i < 8; i++) {
                            const angle = (i/8) * Math.PI * 2 + Date.now()/500;
                            ctx.beginPath();
                            ctx.moveTo(player.x, player.y);
                            ctx.lineTo(
                                player.x + Math.cos(angle) * player.radius,
                                player.y + Math.sin(angle) * player.radius * 1.5
                            );
                            ctx.strokeStyle = `rgba(255, ${150 + Math.sin(Date.now()/300 + i) * 100}, 0, 0.7)`;
                            ctx.lineWidth = 2;
                            ctx.stroke();
                        }
                        break;
                        
                    case 'vortex': 
                        // V√≥rtice espiral girat√≥rio
                        const vortexGradient = ctx.createRadialGradient(
                            player.x, player.y, 5,
                            player.x, player.y, player.radius
                        );
                        vortexGradient.addColorStop(0, 'rgba(0,200,255,0.9)');
                        vortexGradient.addColorStop(0.7, 'rgba(0,100,200,0.5)');
                        vortexGradient.addColorStop(1, 'rgba(0,50,150,0)');
                        
                        ctx.beginPath();
                        ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
                        ctx.fillStyle = vortexGradient;
                        ctx.fill();
                        
                        // Espiral animada
                        const spiralSteps = 20;
                        const timeOffset = Date.now() / 200;
                        
                        ctx.beginPath();
                        for (let i = 0; i <= spiralSteps; i++) {
                            const progress = i / spiralSteps;
                            const angle = progress * Math.PI * 4 + timeOffset;
                            const radius = progress * player.radius;
                            
                            const x = player.x + Math.cos(angle) * radius;
                            const y = player.y + Math.sin(angle) * radius;
                            
                            if (i === 0) {
                                ctx.moveTo(x, y);
                            } else {
                                ctx.lineTo(x, y);
                            }
                        }
                        ctx.strokeStyle = 'rgba(255,255,255,0.7)';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        
                        // √çcone central
                        ctx.font = `${Math.min(40, player.radius/3)}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillStyle = 'white';
                        ctx.fillText('üå™Ô∏è', player.x, player.y);
                        break;
                        
                    case 'shield':
                        // Escudo protetor (jogador 2)
                        ctx.beginPath();
                        ctx.arc(player.x, player.y, player.radius * 1.2, 0, Math.PI * 2);
                        ctx.strokeStyle = 'rgba(0,245,160,0.7)';
                        ctx.lineWidth = 3;
                        ctx.setLineDash([10, 5]);
                        ctx.stroke();
                        ctx.setLineDash([]);
                        
                        ctx.font = '36px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillStyle = player.color;
                        ctx.fillText('üõ°Ô∏è', player.x, player.y);
                        break;
                        
                    case 'heal':
                        // Cura (jogador 2)
                        ctx.font = '36px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillStyle = '#FF5555';
                        ctx.fillText('‚ù§Ô∏è', player.x, player.y);
                        break;
                        
                    case 'teleport':
                        // Teletransporte (jogador 2)
                        ctx.font = '36px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillStyle = '#AA00FF';
                        ctx.fillText('üîÆ', player.x, player.y);
                        break;
                        
                    default: 
                        // Modo normal - mostra o avatar do jogador
                        ctx.font = '36px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillStyle = player.color;
                        
                        // Efeito de pulsa√ß√£o suave
                        const pulse = 1 + Math.sin(Date.now()/500) * 0.1;
                        ctx.setTransform(pulse, 0, 0, pulse, player.x * (1 - pulse), player.y * (1 - pulse));
                        ctx.fillText(player.id === 1 ? 'üê∂' : 'üê±', player.x, player.y);
                        ctx.setTransform(1, 0, 0, 1, 0, 0);
                        
                        // Aura sutil
                        ctx.beginPath();
                        ctx.arc(player.x, player.y, 30, 0, Math.PI * 2);
                        ctx.strokeStyle = player.color + '40';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                }
                
                ctx.restore();
            });
        }

        // SISTEMA DE MENSAGENS
        function showUnlockMessage(text) {
            messageQueue.push(text);
            showNextMessage();
        }

        function showNextMessage() {
            if (isShowingMessage || messageQueue.length === 0) return;

            isShowingMessage = true;
            const text = messageQueue.shift();

            const message = document.createElement('div');
            message.className = 'unlock-message';
            message.textContent = text;

            document.body.appendChild(message);

            setTimeout(() => {
                message.style.opacity = '1';
                message.style.transform = 'translate(-50%, -50%) scale(1)';
            }, 10);

            setTimeout(() => {
                message.style.opacity = '0';
                message.style.transform = 'translate(-50%, -50%) scale(0.9)';

                setTimeout(() => {
                    message.remove();
                    isShowingMessage = false;
                    showNextMessage();
                }, 500);
            }, 2000);
        }

        // CONTADOR DE FPS
        let fps = 0;
        let lastUpdate = performance.now();
        let frameCount = 0;

        function updateFPSCounter() {
            frameCount++;
            const now = performance.now();
            if (now - lastUpdate >= 1000) {
                fps = frameCount;
                frameCount = 0;
                lastUpdate = now;
                document.getElementById('fps-counter').textContent = `FPS: ${fps}`;
            }
        }

        // FUN√á√ïES DE CONTROLE DO JOGO
        function resetGame() {
            if(confirm("Tem certeza que quer reiniciar o jogo? Todo progresso ser√° perdido.")) {
                location.reload();
            }
        }

        function resetGameState() {
            config.players.forEach(player => {
                player.health = player.maxHealth;
            });
            config.xp = 0;
            config.level = 1;
            enemies = [];
            initParticles();
            updateHealthBar();
            updateXPBar();
        }

        // LOOP DO JOGO
        function animate() {
            updateFPSCounter();
            updateBigBangCooldown();
            config.gameTime++;

            // Garante que part√≠culas e inimigos estejam presentes
            if (particles.length < config.particleCount * 0.3) {
                const needed = Math.max(5, config.particleCount - particles.length);
                for (let i = 0; i < needed; i++) {
                    particles.push({
                        x: Math.random() * canvas.width,
                        y: Math.random() * canvas.height,
                        size: Math.random() * 4 + 2,
                        color: `hsl(${Math.random() * 360}, 80%, 60%)`,
                        speedX: (Math.random() - 0.5) * 3,
                        speedY: (Math.random() - 0.5) * 3,
                        baseSpeedX: (Math.random() - 0.5) * 3,
                        baseSpeedY: (Math.random() - 0.5) * 3,
                        trail: []
                    });
                }
            }

            ctx.fillStyle = `rgba(10, 10, 20, ${config.galaxies.current === 'caotica' ? 0.1 : 0.2})`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            updateEnemies();
            updatePowerUps();

            if (config.coopMode) {
                checkCombo();
            }

            // Atualiza efeitos especiais
            if (window.specialEffects) {
                window.specialEffects = window.specialEffects.filter(effect => effect.update());
            }

            particles.forEach((p, index) => {
                if (p.life !== undefined && p.life-- <= 0) {
                    particles.splice(index, 1);
                    return;
                }

                // Aplica comportamento espec√≠fico da gal√°xia
                if (p.behavior) {
                    updateParticleBehavior(p);
                }

                p.speedX = p.baseSpeedX;
                p.speedY = p.baseSpeedY;

                config.players.forEach(player => {
                    if(!player.active || !player.x || !player.y || player.mode === 'normal' || config.isBigBangActive) return;

                    const dx = player.x - p.x;
                    const dy = player.y - p.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const maxDist = player.radius;

                    if(distance < maxDist) {
                        const force = (maxDist - distance) / maxDist;
                        const angle = Math.atan2(dy, dx);

                        switch(player.mode) {
                            case 'attract':
                                const attractForce = 0.1 * player.power * (1 + (maxDist - distance)/maxDist);
                                p.speedX += dx * attractForce;
                                p.speedY += dy * attractForce;

                                if (distance < maxDist * 0.2) {
                                    particles.splice(index, 1);
                                    addXP(3);
                                    config.particlesAbsorbed++;
                                }
                                break;

                            case 'repel':
                                p.speedX -= dx * 0.1 * force * player.power;
                                p.speedY -= dy * 0.1 * force * player.power;

                                if (distance < maxDist * 0.5) {
                                    p.speedX += (Math.random() - 0.5) * force * 5;
                                    p.speedY += (Math.random() - 0.5) * force * 5;
                                    p.color = `hsl(${(Date.now()/10) % 360}, 100%, 70%)`;
                                }
                                break;

                            case 'vortex':
                                const vortexPower = 0.1 * player.power;
                                p.speedX += Math.cos(angle + Math.PI/2) * vortexPower * force;
                                p.speedY += Math.sin(angle + Math.PI/2) * vortexPower * force;
                                p.speedX += dx * 0.03 * force;
                                p.speedY += dy * 0.03 * force;
                                p.color = `hsl(${(angle * 180/Math.PI + Date.now()/10) % 360}, 100%, 70%)`;
                                break;
                        }
                    }
                });

                p.x += p.speedX;
                p.y += p.speedY;

                if (p.x < 0) { p.x = 0; p.speedX *= -0.7; }
                if (p.x > canvas.width) { p.x = canvas.width; p.speedX *= -0.7; }
                if (p.y < 0) { p.y = 0; p.speedY *= -0.7; }
                if (p.y > canvas.height) { p.y = canvas.height; p.speedY *= -0.7; }

                if (p.trail) {
                    p.trail.push({x: p.x, y: p.y});
                    if (p.trail.length > 10) p.trail.shift();
                }
            });

            // Desenha trilhas das part√≠culas
            particles.forEach(p => {
                if (p.trail && p.trail.length > 1) {
                    ctx.beginPath();
                    ctx.moveTo(p.trail[0].x, p.trail[0].y);
                    for (let i = 1; i < p.trail.length; i++) {
                        ctx.lineTo(p.trail[i].x, p.trail[i].y);
                    }
                    ctx.strokeStyle = p.color.replace(')', ', 0.3)').replace('hsl', 'hsla');
                    ctx.lineWidth = p.size / 2;
                    ctx.stroke();
                }

                // Desenha part√≠cula
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            });

            // Desenha efeitos especiais
            if (window.specialEffects) {
                window.specialEffects.forEach(effect => effect.draw());
            }

            drawEnemies();
            drawPowerUps();
            drawPlayers();

            // Atualiza o sistema de ondas
            if(config.wave.spawned < config.wave.enemiesToSpawn && config.gameTime % 60 === 0) {
                spawnEnemy();
                config.wave.spawned++;
            }

            if(enemies.length === 0 && config.wave.spawned >= config.wave.enemiesToSpawn) {
                config.wave.number++;
                config.wave.enemiesToSpawn = 5 + config.wave.number * 2;
                config.wave.spawned = 0;
                showUnlockMessage(`Onda ${config.wave.number} come√ßando!`);
            }

            requestAnimationFrame(animate);
        }

        // Redimensionamento
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            galaxies[config.galaxies.current].init();
        });

        // Teclado
        document.addEventListener('keydown', (e) => {
            switch(e.key.toLowerCase()) {
                case '1': 
                    config.players[0].mode = 'attract'; 
                    break;
                case '2': 
                    config.players[0].mode = 'repel'; 
                    break;
                case '3': 
                    config.players[0].mode = 'vortex'; 
                    break;
                case ' ': 
                    activateBigBang(); 
                    break;
                case '0':
                    config.players[0].mode = 'normal';
                    break;
            }

            if(config.coopMode) {
                const speed = 5;
                const player = config.players[1];

                switch(e.key.toLowerCase()) {
                    case 'w': 
                        player.y = (player.y || canvas.height/2) - speed; 
                        break;
                    case 's': 
                        player.y = (player.y || canvas.height/2) + speed; 
                        break;
                    case 'a': 
                        player.x = (player.x || canvas.width/2) - speed; 
                        break;
                    case 'd': 
                        player.x = (player.x || canvas.width/2) + speed; 
                        break;
                    case 'q': 
                        if (config.players[1].abilities.includes('shield')) {
                            config.players[1].mode = 'shield';
                            activateShield();
                            config.players[1].abilities = config.players[1].abilities.filter(a => a !== 'shield');
                        }
                        break;
                    case 'e': 
                        if (config.players[1].abilities.includes('heal')) {
                            config.players[1].mode = 'heal';
                            activateHeal();
                        }
                        break;
                    case 'r': 
                        if (config.players[1].abilities.includes('teleport')) {
                            config.players[1].mode = 'teleport';
                            setTimeout(() => activateTeleport(), 100);
                        }
                        break;
                    case 'z':
                        config.players[1].mode = 'normal';
                        break;
                }

                if(player.x) player.x = Math.max(10, Math.min(canvas.width - 10, player.x));
                if(player.y) player.y = Math.max(10, Math.min(canvas.height - 10, player.y));
            }
        });

        // Inicia o jogo
        galaxies.classica.init();
        updateHealthBar();
        updateXPBar();
        animate();
    </script>
</body>
</html>